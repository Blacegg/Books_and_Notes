# C++引用（常量引用、左值引用和右值引用）

## 引用

**引用**为对象起了另外一个名字，引用类型为引用另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名：

```c++
int ival = 10;
int &refVal = ival;	//ref指向ival（ref是ival的另外一个名字）
int &refVal2;		//报错：引用必须被初始化
```

一般在初始化变量的时候，初始值会被拷贝到新建的对象中。然而定义引用的时候，程序把引用和它的初始值**绑定（bind）**在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

---

**引用即别名**

**引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字**

定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的：

```C++
//接上述代码
refVal = 2;			//把2赋给refVal只想的对象，此处即是赋值给了ival
int ii = refVal;	//与ii = ival执行结果一样
```

为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值：

```c++
//接上述代码
//正确:refVal3绑定到了那个与 refVal绑定的对象上，这里就是绑定到ival上
int &refVal3 = refVal;
//利用与refVal绑定的对象的值初始化变量i
int i = refVal;		//正确:被初始化为ival的值
```

因为引用本身不是一个对象，所以不能定义引用的引用。

---

**引用的定义**

允许在一条语句中定义多个引用，其中每个引用标识符都必须以符号&开头:

```c++
int i = 1024，i2 = 2048; 	//i和12都是int
int &r = i，r2 = i2;			//r是一个引用，与i绑定在一起，r2是int
int i3 = 1024，&ri = i3;		//i3是int，ri是一个引用，与i3绑定在一起
int &r3 = i3，&r4 = i2; 		//r3和r4都是引用
```

除了后文将要绍的一种例外情况（常量引用），还有一类（将基类的引用绑定到派生类对象上）这里不作介绍，其他所有引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起，相关原因将在后文详述:

```c++
int &refVal4 = 10;		//错误:引用类型的初始值必须是一个对象
double dval = 3.14;
int &refVal5 = dval;	//错误:此处引用类型的初始值必须是 int 型对象
```



## 常量引用

**const 的引用**

可以把引用绑定到 const 对象上，就像绑定到其他对象上一样，我们称之为对**常量的引用(reference toconst)**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象:

```c++
const int ci = 1024;
const int &r1 = ci;		//正确:引用及其对应的对象都是常量
r1 = 42;				//错误:r1是对常量的引用
int &r2 = ci;			//错误:试图让一个非常量引用指向一个常量对象
```

因为不允许直接为ci 赋值，当然也就不能通过引用去改变 ci。因此，对r2 的初始化是错误的。假设该初始化合法，则可以通过 r2 来改变它引用对象的值，这显然是不正确的。

>**术语: 常量引用是对const的引用**
>C++程序员们经常把词组“对const 的引用”简称为“常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已
>严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于 C++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。

---

**引用的隐式类型转换**

允许将绑定在非常量类型的引用转换成绑定在相应常量类型的引用。也就是说，如果T是一种类型，我们就能将绑定T的引用转换成 const  T 的引用。

```c++
int i;
const int &j = i;		//非常量转换成 const int 的引用
int &r = j;				//错误:不允许 const 转换成非常量
```

相反的转换并不存在，因为它试图删除掉底层 const 。

---

**初始化和对const的引用**

前文提到，引用的类型必须与其所用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式:

```c++
int i = 42;
const int &r1 = i;		// 允许将const int&绑定到一个普通int 对象上
const int &r2 = 42;		//正确:r1是一个常量引用
const int &r3 = rl * 2;	//正确:r3是一个常量引用
int &r4 = r1 * 2;		//错误:r4是一个普通的非常量引用
```

要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么:

```c++
double dval = 3.14;
const int &ri = dval;
```

此处 ri引用了一个 int 型的数。对ri 的操作应该是整数运算，但 dval 却是一个双精度浮点数而非整数。因此为了确保让 ri 绑定一个整数，编译器把上述代码变成了如下形式:

```c++
const int temp = 3.14;	//由双精度浮点数生成一个临时的整型常量
const int &ri = temp;	//让ri绑定这个临时量
```

在这种情况下，ri绑定了一个**临时量(temporary)**对象。所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。常常把临时量对象简称为临时量。

接下来探讨当 ri 不是常量时，如果执行了类似于上面的初始化过程将带来什么样的后果。如果 ri不是常量，就允许对 ri 赋值，这样就会改变r 所引用对象的值。注意此时绑定的对象是一个临时量而非 dval。程序员既然让 ri 引用 dval，就肯定想通过ri改变 dval 的值，否则干什么要给 r 赋值呢?如此看来，既然大家基本上不会想着把引用绑定到临时量上，C++语言也就把这种行为归为非法。

---

**对 const 的引用可能引用一个并非 const 的对象**

必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值:

```c++
int i = 42;
int &r1 = i;			// 引用ri绑定对象i
const int &r2 = i ;		// r2也绑定对象i，但是不允许通过r2修改i的值
r1 = 0;					// r1并非常量，i的值修改为0
r2 = 0;					// 错误:r2是一个常量引用
```

r2绑定（非常量）整数i是合法的行为。然而，不允许通过r2修改i的值。尽管如此,i的值仍然允许通过其他途径修改，既可以直接给i赋值，也可以通过像r1一样绑定到i的其他引用来修改。

## 左值引用和右值引用

为了支持移动操作，新标准引入了一种新的引用类型——**右值引用(rvalue reference)**。所谓右值引用就是必须绑定到右值的引用。我们通过& &而不是&来获得右值引用。如我们将要看到的，右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。

一般而言，一个左值表达式表示的定一个对象的身份，而一个右值表达式表示的是对象的值。

类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。如我们所知，对于常规引用(为了与右值引用区分开来，我们可以称之为**左值引用（lvalue reference)**)，我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性:我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上:

```c++
int i = 42;
int &r = i;				//正确:r引用i
int &&rr = i;			//错误:不能将一个右值引用绑定到一个左值上
int &r2 = i * 42;		//错误:i*42是一个右值
const int &r3 = i* 42;	//正确:我们可以将一个 const的引用绑定到一个右值上
int &&rr2 = i* 42;		//正确:将rr2绑定到乘法结果上
```

返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。

返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个const 的左值引用或者一个右值引用绑定到这类表达式上。